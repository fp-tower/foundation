<!DOCTYPE html>
<html>
<head>
  <title>Functors</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body { font-family: 'Droid Serif'; color: #333333; }
    h1 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; color: #074548; }
    h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; color: #6f9a9c; }
    .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    .medium { font-size: 28px; }
    .large { font-size: 36px; }
    .pull-left { float: left; width: 47%; }
    .pull-right { float: right; width: 47%; }
    .large-left { float: left; width: 57%; }
    .small-right { float: right; width: 27%; }
    .medium-right { float: right; width: 37%; }
    .footer { position: absolute; bottom: 12px; left: 45px }
    table { border-collapse: collapse; display: inline-block; }
    th, td { padding: 10px; border: 1px solid black; }
    tr:nth-child(even) {background-color: #f2f2f2;}
  </style>
</head>
<body>
<textarea id="source">

class: center, middle

<a href="https://github.com/julien-truffaut/fp-foundation">
  <img src="img/solid-color-logo.svg" alt="logo" style="width:600px;"/>
</a>

<br>
<br>


# Functors

<br>
<br>

### https://github.com/julien-truffaut/fp-foundation

---
layout: true

<div class="footer">
  <a href="https://github.com/julien-truffaut/fp-foundation">
    <img src="img/symbol-solid-gray-b3b3b3.svg" alt="logo" style="width:100px;"/>
  </a>
</div>

---
.h1[# Plan]

.large[
* Functor hierarchy

* Typeclass coherence
]

---
background-image: url(img/functors/plan.svg)

# Plan

---
class: center, middle

# Functor

---
# Functor

```tut:silent
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

### Laws

```scala
forAll(fa: F[A] => fa.map(identity) == fa)

forAll((fa: F[A], f: A => B, g: B => C) => fa.map(f).map(g) == fa.map(f andThen g))
```

---
# Functor

```tut:silent
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]

  def as[A, B](fa: F[A])(value: B): F[B]
  def void[A](fa: F[A]): F[Unit]
  def tupleL[A, B](fa: F[A])(value: B): F[(B, A)]
  def tupleR[A, B](fa: F[A])(value: B): F[(A, B)]
  def lift[A, B](f: A => B): F[A] => F[B]
}
```

### Laws

```scala
forAll(fa: F[A] => fa.map(identity) == fa)

forAll((fa: F[A], f: A => B, g: B => C) => fa.map(f).map(g) == fa.map(f andThen g))
```

---
# Infix syntax

```tut:silent
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

object syntax {
  implicit class FunctorOps[F[_], A](fa: F[A]){
    def map[B](f: A => B)(implicit ev: Functor[F]): F[B] =
      ev.map(fa)(f)
  }
}
```

```tut:silent
import syntax._

def succF[F[_]: Functor](fi: F[Int]): F[Int] =
  fi.map(_ + 1)

def succF[F[_]](fi: F[Int])(implicit ev: Functor[F]): F[Int] =
  ev.map(fi)(_ + 1)
```

---
background-image: url(img/functors/map-example.svg)

# F as a box or container

---
background-image: url(img/functors/map-example-2.svg)

---
# F as an effect

```scala
type Failure[A] = Option[A] or Either[String, A]

type Nondeterminism[A] = List[A] or Vector[A]

type SideEffect[A] = IO[A]

type MutableState[A] = State[Int, A]

type ImmutableState[A] = Reader[Int, A]

type Console[A] = ...

type Logger[A] = ...
```

--

### A Functor is an abstraction allowing to update an effectful value **without** altering its effect

---
background-image: url(img/functors/functor-api-law.svg)

---
class: center, middle

# Exercise 1

---
.h1[# Functor]

.pull-left[
### ✅ ADT

```tut:silent
case class Foo[A](i: Int, a: A)

sealed trait Bar[A]
case class Bar1[A](i: Int    , a: A) extends Bar[A]
case class Bar2[A](b: Boolean, a: A) extends Bar[A]
case class Bar3[A](s: String       ) extends Bar[A]
```

### ❌ Function input

```tut:silent
case class Predicate[A](func: A => Boolean)
```
]

.pull-right[
### ✅ Function result

```tut:silent
case class Producer[A](func: Int => A)
```
]

---
# Functor variance

.center[![Functors](img/functors/functor-variance.svg)]

```tut:silent
trait InvariantFunctor[F[_]]{
  def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
}

trait ContravariantFunctor[F[_]] extends InvariantFunctor[F] {
  def contramap[A, B](fa: F[A])(f: B => A): F[B]
}

trait Functor[F[_]] extends InvariantFunctor[F] { // CovariantFunctor
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

---
# Functor variance

```tut:invisible
type Json = String
```

```tut:silent
trait JsonDecoder[A]{
  def decode(value: Json): A
}

trait JsonEncoder[A]{
  def encode(value: A): Json
}

trait JsonCodec[A] extends JsonDecoder[A] with JsonEncoder[A]
```

---
# Functor variance

```tut:silent
case class JsonDecoder[A](decode: Json => A)

case class JsonEncoder[A](encode: A    => Json)

case class JsonCodec[A](
  decode: Json => A,
  encode: A    => Json
)
```

--

```scala
implicit val decoderFunctor: Functor[JsonDecoder] = ???

implicit val encoderFunctor: ContravariantFunctor[JsonEncoder] = ???

implicit val codecFunctor  : InvariantFunctor[JsonCodec] = ???
```

---
.h1[# Variance]

<br>
<br>
<br>

.center[
|  Type        | A             | B         |
|:------------:|:-------------:|:---------:|
| (A, B)       | Covariant     | Covariant |
| Either[A, B] | Covariant     | Covariant |
| A => B       | Contravariant | Covariant |
| A => A       | Invariant     | N/A       |
]

---
.h1[# Variance]

<br>
<br>
<br>

.center[
| Type          | A             | B             | C        |
|:-------------:|:-------------:|:-------------:|:---------:|
| (A => B) => C | Covariant     | Contravariant |Covariant |

<br>
<br>

[Thinking with types](https://leanpub.com/thinking-with-types) by Sandy Maguire
]

---
class: center, middle

# Applicative

---
.h1[# Applicative]

.large-left[
```tut:silent
trait Applicative[F[_]] extends Functor[F] {


  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]


  def pure[A](a: A): F[A]


}
```
]

.small-right[![Applicative main methods](img/functors/applicative-main.svg)]

---
.h1[# Applicative]

.large-left[
```tut:silent
trait Applicative[F[_]] extends Functor[F] {
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]
  def pure[A](a: A): F[A]


  def tuple2[A, B](fa: F[A], fb: F[B]): F[(A, B)]


  def unit: F[Unit]

}
```
]

.small-right[![Applicative main methods](img/functors/applicative-tuple2-unit.svg)]

---
.h1[# Applicative]

.large-left[
```tut:silent
trait Applicative[F[_]] extends Functor[F] {
  def pure[A](a: A): F[A]
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]


  // <*
  def productL[A, B](fa: F[A], fb: F[B]): F[A]


  // *>
  def productR[A, B](fa: F[A], fb: F[B]): F[B]

}
```
]

.small-right[![Applicative main methods](img/functors/applicative-productL-productR.svg)]

---
.h1[# Applicative]

.large-left[
```tut:silent
trait Applicative[F[_]] extends Functor[F] {
  def pure[A](a: A): F[A]
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]


  def map3[A, B, C, D](fa: F[A], fb: F[B], fc: F[C])
                      (f: (A, B, C) => D): F[D]


  def tuple3[A, B, C](fa: F[A], fb: F[B], fc: F[C]): F[(A, B, C)]

}
```
]

.small-right[![Applicative main methods](img/functors/applicative-map3-tuple3.svg)]

---
# Applicative

```tut:silent
trait Applicative[F[_]] extends Functor[F] {
  def pure[A](a: A): F[A]
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]

  def tuple2[A, B](fa: F[A], fb: F[B]): F[(A, B)]
  def unit: F[Unit]
}
```

### Laws

```scala
forAll(fa: F[A] => tuple2(fa  , unit) == fa)
forAll(fa: F[A] => tuple2(unit, fa  ) == fa)

forAll((fa: F[A], fb: F[A], fc: F[C]) => tuple2(tuple2(fa, fb), fc) == tuple2(fa, tuple2(fb, fc)))

// equalities hold if we flatten tuples, e.g. (a, ()) == a == ((), a)
```

???
`=~` because `a` is isomorphic to `(a, ())` and `((), a)`

same for `(a, (b, c))` and `((a, b), c)`

---
background-image: url(img/functors/applicative-api-law.svg)

---
# Applicative is a Monoidal Functor

```scala
combine  :: A    => A    => A
tuple2   :: F[A] => F[B] => F[(A, B)]
```

```scala
empty ::      A
pure  :: A => F[A]
```

### Laws

```scala
forAll(a:  A    => combine(a, empty) == a )
forAll(fa: F[A] => tuple2(fa, unit ) =~ fa)

forAll(a:  A    => combine(empty, a ) == a )
forAll(fa: F[A] => tuple2(unit  , fa) =~ fa)

forAll(( a: A   ,  b: B   ,  c: C)    => combine(combine(a, b), c)  == combine(a, combine(b, c)))
forAll((fa: F[A], fb: F[A], fc: F[C]) => tuple2(tuple2(fa, fb), fc) =~ tuple2(fa, tuple2(fb, fc)))
```

---
# Applicative combine effects: Failure

```tut:reset:invisible
import exercises.functors.Applicative.syntax._
import answers.functors.FunctorsAnswers.optionMonad
import answers.functors.FunctorsAnswers.listMonad
```

```tut
(Option(1), Option("hello")).tuple2
(Option(1), None).tuple2
(None, Some(2)).tuple2
```

--

```tut
10.pure[Option]
(1.pure[Option], 10.pure[Option]).map2(_ + _)
```

---
# Applicative combine effects: Nondeterminism


```tut
(List(1,2,3), List("foo", "bar")).tuple2
```

--

```tut
10.pure[List]
(List(1,2,3), 10.pure[List]).map2(_ + _)
```

---
class: center, middle

# Exercise 2

---
.h1[# Applicative is a Functor]

```tut:invisible
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

.large-left[
```tut:silent
trait Applicative[F[_]] extends Functor[F] {

  def pure[A](a: A): F[A]

  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C]

}
```

### Coherence Law

```scala
forAll((fa: F[A], f: A => B) =>
  (fa, pure(())).map2((a, _) => f(a)) == fa.map(f)
)
```
]

.medium-right[![Applicative Map Coherence](img/functors/applicative-map-coherence.svg)]

---
class: center, middle

# Monad

---
# Monad

```tut:silent
trait Monad[F[_]] extends Applicative[F] {

  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]

  def flatten[A](ffa: F[F[A]]): F[A]

}
```

### Laws

```scala
forAll(fa: F[A]             => fa.flatMap(pure)   == fa)
forAll((a: A, f: A => F[B]) => pure(a).flatMap(f) == f(a))

forAll((fa: F[A], f: A => F[B], g: B => F[C]) =>
  fa.flatMap(f).flatMap(g) == fa.flatMap(a => f(a).flatMap(g))
)
```

---
background-image: url(img/functors/monad-api-law.svg)

---
class: center, middle

# Exercise 3

---
# Monad is an Applicative

```tut:silent
trait Monad[F[_]] extends Applicative[F] {

  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]

  def flatten[A](ffa: F[F[A]]): F[A]

}
```

### Coherence Law

```scala
forAll((fa: F[A], fb: F[B]) =>
  fa.flatMap(a => fb.map(b => (a, b))) == (fa, fb).tuple2
)
```

---
# Monad is an Applicative

```tut:silent
trait Monad[F[_]] extends Applicative[F] {

  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]

  def flatten[A](ffa: F[F[A]]): F[A]

}
```

### Coherence Law

```scala
forAll((fa: F[A], fb: F[B]) =>
  (for {
    a <- fa
    b <- fb
  } yield (a, b)) == (fa, fb).tuple2
)
```

---
class: center, middle

# Traverse

---
# Traverse

```tut:invisible
import exercises.typeclass.Foldable
```

```tut:silent
trait Traverse[F[_]] extends Functor[F] with Foldable[F] {

  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]]

  def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]]

}
```

### Law

```scala
forAll(fa: F[A] => fa.traverse(Id(_)).value == fa)
```

---
background-image: url(img/functors/traverse-api-law.svg)

---
class: center, middle

# Exercise 4

---
# Traverse is a Functor

```tut:silent
trait Traverse[F[_]] extends Functor[F] with Foldable[F] {

  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]]

  def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]]

}
```

### Coherence Law

```scala
forAll((fa: F[A], f: A => B) => fa.traverse(a => Id(f(a))).value == fa.map(f))
```

---
# Traverse is a Foldable

```tut:silent
trait Traverse[F[_]] extends Functor[F] with Foldable[F] {

  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]]

  def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]]

}
```

### Coherence Law

```scala
forAll((fa: F[A], f: A => B) => fa.traverse(a => Const(f(a))).getConst == fa.foldMap(f))
```


---
# Default implementation

```scala
traverse > foldMap > size
```


```scala
def sizeDefault[F[_]: Traverse, A](fa: F[A]): Int =
  fa.traverse(_ => Const(1)).getConst
```


```scala
sizeDefault = (Const(1) |+| Const(1) |+| ... |+| Const(1)).getConst  // O(n)
```

--

```scala
val vectorTraverse: Traverse[Vector] = new Traverse[Vector] {
  def traverse[G[_]: Applicative, A, B](fa: Vector[A])(f: A => G[B]): G[Vector[B]] = ???
  overload def size[A](fa: Vector[A]): Int = fa.size // O(1)
}
```

--

### Coherence law

```scala
forAll(fa: F[A] => fa.size == sizeDefault(fa))
```

---
background-image: url(img/functors/review.svg)

# Review

---
class: center, middle

# Granularity

---
background-image: url(img/functors/cats-semigroup.svg)

# Semigroups

---
background-image: url(img/functors/cats-functor.svg)

# Functors

---
# Resources and further study

* [Cats infographic](https://github.com/tpolecat/cats-infographic): typeclass diagrams for cats
* [Thinking with types](https://leanpub.com/thinking-with-types): variance

---
class: center, middle

# Chapter 5: IO / Effects (TODO)

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9",
        slideNumberFormat: '%current%'
    });
</script>
</body>
</html>
